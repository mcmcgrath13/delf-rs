var searchIndex = JSON.parse('{\
"delf":{"doc":"DeLFA DelF inspired deletion framework in Rust.","i":[[0,"api","delf","The api module contains routes to dispatch deletes on …",null,null],[5,"delete_object","delf::api","<code>DELETE</code> API endpoint to delete an object of the given type …",null,[[["state",3],["string",3],["delfyamls",3]],["status",3]]],[5,"rocket_route_fn_delete_object","","Rocket code generated wrapping route function.",null,[[["data",3],["request",3]],["outcome",6]]],[7,"static_rocket_route_info_for_delete_object","","Rocket code generated static route info.",null,null],[5,"delete_edge","","<code>DELETE</code> API endpoint to delete an edge of the given type …",null,[[["state",3],["string",3],["delfyamls",3]],["status",3]]],[5,"rocket_route_fn_delete_edge","","Rocket code generated wrapping route function.",null,[[["data",3],["request",3]],["outcome",6]]],[7,"static_rocket_route_info_for_delete_edge","","Rocket code generated static route info.",null,null],[0,"graph","delf","The graph module contains the core structures to run the …",null,null],[0,"edge","delf::graph","The edge of a DelfGraph is a DelfEdge",null,null],[4,"DeleteType","delf::graph::edge","The deletion types for a DelfEdge.  The type describes …",null,null],[13,"Deep","","Delete the edge and object the edge refers to",0,null],[13,"Shallow","","Delete the edge, but not the object it refers to",0,null],[13,"RefCount","","Delete the edge and delete the object if this edge is the …",0,null],[3,"ToType","","Describes the object from the point of view of the edge",null,null],[12,"object_type","","",1,null],[12,"field","","",1,null],[12,"mapping_table","","",1,null],[3,"DelfEdge","","The DelfEdge contains the information about the edge as …",null,null],[12,"name","","The unique name identifying the edge, used by the API to …",2,null],[12,"to","","Describes the object the edge points to.",2,null],[12,"deletion","","How should the deletion of this edge affect the object it …",2,null],[12,"inverse","","If this edge is deleted (typically, shallowly), is there …",2,null],[11,"delete_one","","Delete a specific edge between two object instances",2,[[["string",3],["delfgraph",3]]]],[11,"delete_all","","Delete all edges of a given type from the instance of the …",2,[[["string",3],["delfgraph",3]]]],[11,"validate","","Validate the edge exists in the storage as described in …",2,[[["delfgraph",3]],[["result",4],["string",3]]]],[0,"object","delf::graph","The node of a DelfGraph is a DelfObject",null,null],[4,"DeleteType","delf::graph::object","The deletion types for a DelfObject",null,null],[13,"ByAny","","This object can be deleted by any incoming edge, but not …",3,null],[13,"ShortTTL","","This object will be deleted after the specified period of …",3,null],[13,"Directly","","This object can be deleted by any incoming edge, as well …",3,null],[13,"DirectlyOnly","","This object can only be deleted direcly",3,null],[13,"ByXOnly","","This object can only be deleted by the edges listed in …",3,null],[13,"NotDeleted","","This object cannot be deleted",3,null],[3,"DelfObject","","The DelfObject contains the information about the object …",null,null],[12,"name","","",4,null],[12,"storage","","",4,null],[12,"deletion","","",4,null],[12,"id_field","","",4,null],[12,"id_type","","",4,null],[12,"time_field","","",4,null],[11,"delete","","Delete an instance of this object given the id.",4,[[["hashmap",3],["option",4],["string",3],["delfedge",3]]]],[11,"validate","","Validate the object exists in the storage as described in …",4,[[["hashmap",3]],[["result",4],["string",3]]]],[11,"check_short_ttl","","If the delete type is <code>short_ttl</code>, return ids of instances …",4,[[["hashmap",3]],[["vec",3],["string",3]]]],[3,"DelfGraph","delf::graph","The DelfGraph is the core structure for delf\'s …",null,null],[11,"new","","Create a new DelfGraph from a schema and a config.  See …",5,[[["delfyamls",3]],["delfgraph",3]]],[11,"print","","Pretty print the graph\'s contents.",5,[[]]],[11,"get_edge","","Given an edge name, get the corresponding DelfEdge",5,[[["string",3]],["delfedge",3]]],[11,"delete_edge","","Given an edge name and the ids of the to/from object …",5,[[["string",3]]]],[11,"get_object","","Given an object name, get the corresponding DelfObject",5,[[["string",3]],["delfobject",3]]],[11,"delete_object","","Given the object name and the id of the instance, delete …",5,[[["string",3]]]],[11,"validate","","Validate that the objects and edges described in the …",5,[[]]],[11,"check_short_ttl","","Check all objects in the DelfGraph with the deletion type …",5,[[]]],[0,"storage","delf","The storage module contains plugins for storage-specific …",null,null],[8,"DelfStorageConnection","delf::storage","Trait defining the api for a DelF storage connection.",null,null],[10,"connect","","Connect to the storage via a connection string",6,[[]]],[10,"get_object_ids","","Get the object ids of the object an edge points to.",6,[[["string",3]],[["vec",3],["string",3]]]],[10,"get_object_ids_by_time","","Get the object ids that have a <code>time_field</code> with a value …",6,[[["string",3]],[["vec",3],["string",3]]]],[10,"delete_edge","","Delete an edge instance.",6,[[["delfobject",3],["option",4],["string",3],["delfedge",3]]]],[10,"delete_object","","Delete an object instance.",6,[[["delfobject",3],["string",3]]]],[10,"validate_edge","","Validate the edge exists in the storage as described in …",6,[[["delfedge",3]],[["result",4],["string",3]]]],[10,"validate_object","","Validate the object exists in the storage as described in …",6,[[["delfobject",3]],[["result",4],["string",3]]]],[10,"has_edge","","Check if an inbound edge exists for a given object …",6,[[["delfobject",3],["string",3],["delfedge",3]]]],[5,"get_connection","","Given the name of the plugin (trait implementor) and the …",null,[[],[["box",3],["delfstorageconnection",8]]]],[3,"DelfYamls","delf","Convenience structure for passing around parsed yaml files",null,null],[12,"config","","",7,null],[12,"schema","","",7,null],[5,"read_files","","Read in the schema and config yaml files to construct the …",null,[[["string",3]],["delfgraph",3]]],[5,"read_yamls","","Read in the schema and config yaml strings to construct …",null,[[],["delfgraph",3]]],[5,"init_api","","Initialize the rocket api and return the struct.  Run the …",null,[[["string",3]],["rocket",3]]],[5,"check_short_ttl_loop","","Spawn a thread that checks short time to live objects …",null,[[["string",3]]]],[11,"from","delf::graph::edge","",0,[[]]],[11,"into","","",0,[[]]],[11,"to_owned","","",0,[[]]],[11,"clone_into","","",0,[[]]],[11,"borrow","","",0,[[]]],[11,"borrow_mut","","",0,[[]]],[11,"try_from","","",0,[[],["result",4]]],[11,"try_into","","",0,[[],["result",4]]],[11,"type_id","","",0,[[],["typeid",3]]],[11,"into_collection","","",0,[[],["smallvec",3]]],[11,"mapped","","",0,[[],["smallvec",3]]],[11,"as_result","","",0,[[],[["result",4],["parseerr",3]]]],[11,"vzip","","",0,[[]]],[11,"from","","",1,[[]]],[11,"into","","",1,[[]]],[11,"to_owned","","",1,[[]]],[11,"clone_into","","",1,[[]]],[11,"borrow","","",1,[[]]],[11,"borrow_mut","","",1,[[]]],[11,"try_from","","",1,[[],["result",4]]],[11,"try_into","","",1,[[],["result",4]]],[11,"type_id","","",1,[[],["typeid",3]]],[11,"into_collection","","",1,[[],["smallvec",3]]],[11,"mapped","","",1,[[],["smallvec",3]]],[11,"as_result","","",1,[[],[["result",4],["parseerr",3]]]],[11,"vzip","","",1,[[]]],[11,"from","","",2,[[]]],[11,"into","","",2,[[]]],[11,"to_owned","","",2,[[]]],[11,"clone_into","","",2,[[]]],[11,"borrow","","",2,[[]]],[11,"borrow_mut","","",2,[[]]],[11,"try_from","","",2,[[],["result",4]]],[11,"try_into","","",2,[[],["result",4]]],[11,"type_id","","",2,[[],["typeid",3]]],[11,"into_collection","","",2,[[],["smallvec",3]]],[11,"mapped","","",2,[[],["smallvec",3]]],[11,"as_result","","",2,[[],[["result",4],["parseerr",3]]]],[11,"vzip","","",2,[[]]],[11,"from","delf::graph::object","",3,[[]]],[11,"into","","",3,[[]]],[11,"to_owned","","",3,[[]]],[11,"clone_into","","",3,[[]]],[11,"borrow","","",3,[[]]],[11,"borrow_mut","","",3,[[]]],[11,"try_from","","",3,[[],["result",4]]],[11,"try_into","","",3,[[],["result",4]]],[11,"type_id","","",3,[[],["typeid",3]]],[11,"into_collection","","",3,[[],["smallvec",3]]],[11,"mapped","","",3,[[],["smallvec",3]]],[11,"as_result","","",3,[[],[["result",4],["parseerr",3]]]],[11,"vzip","","",3,[[]]],[11,"from","","",4,[[]]],[11,"into","","",4,[[]]],[11,"to_owned","","",4,[[]]],[11,"clone_into","","",4,[[]]],[11,"borrow","","",4,[[]]],[11,"borrow_mut","","",4,[[]]],[11,"try_from","","",4,[[],["result",4]]],[11,"try_into","","",4,[[],["result",4]]],[11,"type_id","","",4,[[],["typeid",3]]],[11,"into_collection","","",4,[[],["smallvec",3]]],[11,"mapped","","",4,[[],["smallvec",3]]],[11,"as_result","","",4,[[],[["result",4],["parseerr",3]]]],[11,"vzip","","",4,[[]]],[11,"from","delf::graph","",5,[[]]],[11,"into","","",5,[[]]],[11,"borrow","","",5,[[]]],[11,"borrow_mut","","",5,[[]]],[11,"try_from","","",5,[[],["result",4]]],[11,"try_into","","",5,[[],["result",4]]],[11,"type_id","","",5,[[],["typeid",3]]],[11,"into_collection","","",5,[[],["smallvec",3]]],[11,"mapped","","",5,[[],["smallvec",3]]],[11,"as_result","","",5,[[],[["result",4],["parseerr",3]]]],[11,"vzip","","",5,[[]]],[11,"from","delf","",7,[[]]],[11,"into","","",7,[[]]],[11,"borrow","","",7,[[]]],[11,"borrow_mut","","",7,[[]]],[11,"try_from","","",7,[[],["result",4]]],[11,"try_into","","",7,[[],["result",4]]],[11,"type_id","","",7,[[],["typeid",3]]],[11,"into_collection","","",7,[[],["smallvec",3]]],[11,"mapped","","",7,[[],["smallvec",3]]],[11,"as_result","","",7,[[],[["result",4],["parseerr",3]]]],[11,"vzip","","",7,[[]]],[11,"from","delf::graph::edge","Create a DelfEdge from a yaml struct.  The keys <code>name</code>, <code>to</code> …",2,[[["yaml",4]],["delfedge",3]]],[11,"from","","Create a ToType from a yaml struct. The expected keys are …",1,[[["yaml",4]],["totype",3]]],[11,"from","delf::graph::object","Construct a DelfObject from yaml.  The keys <code>name</code>, <code>storage</code>…",4,[[["yaml",4]],["delfobject",3]]],[11,"clone","delf::graph::edge","",0,[[],["deletetype",4]]],[11,"clone","","",1,[[],["totype",3]]],[11,"clone","","",2,[[],["delfedge",3]]],[11,"clone","delf::graph::object","",3,[[],["deletetype",4]]],[11,"clone","","",4,[[],["delfobject",3]]],[11,"eq","delf::graph::edge","",0,[[["deletetype",4]]]],[11,"eq","","",1,[[["totype",3]]]],[11,"ne","","",1,[[["totype",3]]]],[11,"eq","","",2,[[["delfedge",3]]]],[11,"ne","","",2,[[["delfedge",3]]]],[11,"fmt","","",0,[[["formatter",3]],["result",6]]],[11,"fmt","","",1,[[["formatter",3]],["result",6]]],[11,"fmt","","",2,[[["formatter",3]],["result",6]]],[11,"fmt","delf::graph::object","",3,[[["formatter",3]],["result",6]]],[11,"fmt","","",4,[[["formatter",3]],["result",6]]],[11,"fmt","delf::graph","",5,[[["formatter",3]],["result",6]]]],"p":[[4,"DeleteType"],[3,"ToType"],[3,"DelfEdge"],[4,"DeleteType"],[3,"DelfObject"],[3,"DelfGraph"],[8,"DelfStorageConnection"],[3,"DelfYamls"]]}\
}');
addSearchOptions(searchIndex);initSearch(searchIndex);